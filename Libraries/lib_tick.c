/******************************************************************************
 * @File: lib_tick.c
 * @Author: Milandr, L.
 * @Project: Library
 * @Version: 1.0.1
 * @Compiler: ARM Compiler V5.06 (build 750)
 * @Microcontroller: К1986ВЕ92QI
 * @Device: Отладочная плата «МилКиТЭС»
 * @Date: 20.03.2020
 * @Purpose: Реализация временной базы
 ******************************************************************************/

// Подключение заголовка
#include "lib_tick.h"

// Инициализация глобальных переменных
// Массив для хранения квантовых меток
uint32_t mark[WAIT_NUM] = {0};

// Кванты работы системы
// (по умолчанию 1 квант = 1 миллисекунде)
uint32_t system_ticks = 0;

// Инициализация системного таймера
void TICK_Init(void)
{
  // Деинициализация
  SysTick->CTRL = 0;
  SysTick->LOAD = 0;
  SysTick->VAL  = 0;

  // Установка периода перезагрузки
  SysTick->LOAD = (SystemCoreClock / SYSTEM_TICK_RATE) - 1;

  // Конфигурация
  SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos)      // Работа таймера (включён)
                | (1 << SysTick_CTRL_TICKINT_Pos)     // Запрос на прерывание (разрешён)
                | (1 << SysTick_CTRL_CLKSOURCE_Pos);  // Источник тактирования таймера (HCLK)

  // Конфигурация контроллера NVIC
  NVIC_SetPriority(SysTick_IRQn, 7);  // Приоритет прерываний
  NVIC_EnableIRQ(SysTick_IRQn);       // Разрешение обработки прерываний
}

// Реализация интервала ожидания:
// false - ожидание в процессе; true - ожидание завершено или неактивно
bool Wait(uint32_t *mark, uint32_t wait_ticks)
{
  // Создание квантовой метки
  if (*mark == 0) {

    // Метка задаётся как сумма текущих системных квантов
    // и заданных квантов ожидания
    *mark = system_ticks + wait_ticks;

    // Позитивный выход:
    // требуется, чтобы задержка начиналась
    // ПОСЛЕ первого выполнения блока кода
    return true;
  }

  // Если значение системных квантов превышает значение метки,
  // то выполняется деинициализация (сброс) этой метки
  // (т.е. интервал ожидания истёк)
  if (system_ticks >= *mark) {
    *mark = 0;
  }

  // Негативный выход
  return false;
}

// Обработчик аппаратных прерываний от SysTick
void SysTick_Handler(void)
{
  // Инкремент значения системных квантов
  system_ticks++;
}
